% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PMLInfoApprox.R
\name{PMLInfoApprox}
\alias{PMLInfoApprox}
\title{Approximate the information matrix for the model parameters}
\usage{
PMLInfoApprox(
  X,
  method = "MQL",
  nChoiceSet,
  effectMean,
  effectVar,
  opts = list(nY = 1000, nU = 1000),
  Y = NULL
)
}
\arguments{
\item{X}{model matrix (a 3d array).}

\item{method}{Choice of approximation method. Options are MQL, PQL, MSM, Laplace, or Importance}

\item{nChoiceSet}{Number of choice sets}

\item{effectMean}{Vector of means for the effects coded attribute effects}

\item{effectVar}{Vector of variances for the effects coded attribute effects}

\item{opts}{Additional options controlling the number of samples used in evaluation}

\item{Y}{an enumeration of all possible responses. This is only required for importance sampling}
}
\value{
The approximation to the information matrix for the model parameters
}
\description{
Approximate the information matrix for the model parameters
}
\examples{
# Libraries
library(DoE.base)

# 3 attributes
nattr <- 3

# 6 choice sets
nChoiceSet <- 6

# 2 alternatives per choice set
nAlternative <- 2 

# 3 factors, each at 2 levels
nLevelAttribute <- c(2, 2, 2)

# effect means
mu <- c(1.0, -0.4, -0.8)

# effect variances
sig <- c(0.5, 0.3, 0.4)

# indices for alternatives
st = NULL

# all possible design points
fullfac <- purrr::quietly(fac.design)(nlevels=nLevelAttribute, random=FALSE)$result

# Generate a random design
for(i in 1:nChoiceSet){
    st = c( st, sample(prod(nLevelAttribute), nAlternative, replace=TRUE) )
}
designm=(fullfac)[st,]

# Effects coding
contr=rep('contr.sum',nattr)
names(contr)=names(designm)
contr=as.list(contr)
M = model.matrix(~., designm, contrasts = contr)[,-1] 

infoAppr <- PMLInfoApprox(M, method = "PQL",
    nChoiceSet = nChoiceSet, effectMean = mu, effectVar = sig) 

}
